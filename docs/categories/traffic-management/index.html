<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><meta name="generator" content="Hugo 0.68.3" /><link href="https://fonts.googleapis.com/css?family=Chivo|Fira+Code|Noto+Sans&display=swap" rel="stylesheet">
<link rel="shortcut icon" href="../../images/spider-web.png">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light only">
<meta name="supported-color-schemes" content="light only"><title>Traffic Management&nbsp;&ndash;&nbsp;Istio By Example</title><link rel="stylesheet" href="../../css/core.min.97825e77f989d457fa83a8524e96cff0874b1c579a52143002d795e06c7f755f657f8522f861266f6b8d4c32dc387543.css" integrity="sha384-l4Jed/mJ1Ff6g6hSTpbP8IdLHFeaUhQwAteV4Gx/dV9lf4Ui&#43;GEmb2uNTDLcOHVD"><meta property="og:title" content="Traffic Management" />
<meta property="og:description" content="The examples highlighting various Istio features." />
<meta property="og:type" content="website" />
<meta property="og:url" content="/categories/traffic-management/" />
<meta property="og:image" content="/images/istio-framed.jpg"/>
<meta property="og:updated_time" content="2019-12-31T00:00:00+00:00" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="/images/istio-framed.jpg"/>
<meta name="twitter:title" content="Traffic Management"/>
<meta name="twitter:description" content="The examples highlighting various Istio features."/>
</head>
<body>
    <div class="base-body max-width"><section id="header" class="header max-body-width">
    <p><a class="home" href="../../"><img class="site-logo" src="../../images/istio-logo.png" alt />
            <span class="site-name">Istio By Example</span></a></p>
</section><div id="content" class="flex-body max-body-width"><h1>Traffic Management</h1><ul class="note-list"><li><a class="note" href="../../databases/">
            <p class="note-title">Database Traffic</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">Applications often span multiple environments, and databases are a great example. You might choose to run your database outside of Kubernetes for legacy or storage reasons, or you might use a managed database service.
But fear not! You can still add external databases to your Istio service mesh. Let&rsquo;s see how.

Here, we have a plants service running inside a Kubernetes cluster, with Istio enabled. plants writes inventory to a Firestore NoSQL database running in Google Cloud, using the Golang client library for Firestore.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../external-services/">
            <p class="note-title">External Services</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">A service mesh often spans one environment— for instance, one Kubernetes cluster. And together, all the connected services in that environment form the management domain of that mesh, from which you can view metrics and set policies.
But what if you are also running services outside the cluster, or you depend on external APIs?
Have no fear. Istio provides a resource called a ServiceEntry that lets you logically bring external services into your mesh &ndash; even services you don&rsquo;t own.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../fault-injection/">
            <p class="note-title">Fault Injection</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">Adopting microservices often means more dependencies, and more services you might not control. It also means more requests on the network, increasing the possibility for errors. For these reasons, it&rsquo;s important to test your services&rsquo; behavior when upstream dependencies fail.
Chaos testing is the process of deliberately breaking your services in order to expose weaknesses and improve fault tolerance. Chaos testing can reveal client-side bugs, or identify user-facing failure situations where you might want to display a cached result, instead of returning an error.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../grpc/">
            <p class="note-title">gRPC</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">gRPC is a communication protocol for services, built on HTTP/2. Unlike REST over HTTP/1, which is based on resources, gRPC is based on Service Definitions. You specify service definitions in a format called protocol buffers (&ldquo;proto&rdquo;), which can be serialized into an small binary format for transmission.
With gRPC, you can generate boilerplate code from .proto files into multiple programming languages, making gRPC an ideal choice for polyglot microservices.
While gRPC supports some networking use cases like TLS and client-side load balancing, adding Istio to a gRPC architecture can be useful for collecting telemetry, adding traffic rules, and setting RPC-level authorization.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../ingress/">
            <p class="note-title">Ingress</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">Ingress traffic refers to traffic entering the mesh from outside the cluster. Kubernetes provides ways to handle ingress traffic. With Istio, you can instead manage ingress traffic with a Gateway.
A Gateway is a standalone set of Envoy proxies that load-balance inbound traffic. Istio deploys a default IngressGateway with a public IP address, which you can configure to expose applications inside your service mesh to the Internet.
Istio Gateways have two key advantages over traditional Kubernetes Ingress.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../load-balancing/">
            <p class="note-title">Load Balancing</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">Kubernetes supports load balancing for inbound traffic. But what about Kubernetes services inside the cluster?
When in-cluster services communicate, a load balancer called kube-proxy forwards requests to service pods at random. You can use Istio to add more complex load balancing methods, enabled by Envoy.
Envoy supports multiple load balancing methods, including random, round-robin, and least request.
Let&rsquo;s see how to use Istio to add least request load balancing for a service called payments, which processes all transactions for a web frontend.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../locality-load-balancing/">
            <p class="note-title">Locality Load Balancing</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">If you&rsquo;re running a high-scale, global application, you might be running services in multiple regions. If you have multiple replicas of the same service, you may want to direct client requests to the closest server, in order to minimize latency. You might also want a way to handle failover if one region goes down, and direct traffic to the closest available service.
Istio can help you automatically handle regional traffic using a feature called locality load balancing.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../response-headers/">
            <p class="note-title">Modify Response Headers</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">With Istio, you can apply traffic rules to route based on HTTP request headers. You can also use Istio to modify response headers. This could be useful if you want to strip headers generated by your application, or if you want to add response headers without changing your application code.

In this example, we will apply an Istio VirtualService to add a new header (hello:world), then remove the set-cookie header.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../monitoring-egress-traffic/">
            <p class="note-title">Monitoring Egress Traffic</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">One way to think about a service mesh is as a domain of control. Within a Kubernetes namespace where Istio sidecar injection is enabled, you can monitor all traffic between Pods, and enforce security policies.
But what about upstream services that live outside the mesh? How do you determine at runtime which services call external APIs? How do you know which database instance your service is writing to? Or how do you ensure that a service inside the mesh is only sending traffic within its own geographic region?…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li><li><a class="note" href="../../multiple-traffic-rules/">
            <p class="note-title">Multiple Traffic Rules</p>
            <p class="note-date">2019-12-31</p>
            <p class="note-content">Istio supports lots of traffic management use cases, from redirects and traffic splitting to mirroring and retry logic. If you&rsquo;ve created an Istio VirtualService to define one of these policies for a service, it&rsquo;s easy to add more traffic management rules to the same resource. This example demonstrates how to apply multiple traffic rules to one Kubernetes-based service.
Let&rsquo;s say that we&rsquo;re on the frontend engineering team for a newspaper&rsquo;s website.…</p></a><p class="note-labels"><a class="article-category" href="../../categories/traffic-management/"><span class="hashtag">#</span>Traffic Management</a></p></li></ul><div class="pagination">
    <ul><li><a class="active" href="../../categories/traffic-management/">1</a></li><li><a class="" href="../../categories/traffic-management/page/2/">2</a></li></ul>
</div><section id="footer" class="footer">
    <p>Made with ❤️ by <a href="https://twitter.com/askmeegs">Megan O'Keefe</a> | <a href="https://github.com/askmeegs/istiobyexample">Source</a> | <a href="https://github.com/cntrump/hugo-notepadium">Theme</a></p>
</section></div>
    </div>
</body>
</html>